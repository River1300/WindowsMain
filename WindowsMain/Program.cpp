/* COM : Component Object Model */

/*
재사용이 가능한 컴포넌트를 만들어 배포를 쉽게해준다.
용산에서 조립 PC를 하나 맞춘다고 생각해보자. 에산이 100만원이면 견적 사이트에서 원하는 HDD, 메인보드, CPU,
그래픽카드들을 찾아서 조합할것, 이런 각 부품들은 당연히 서로 하나로 조립이 가능하며, 100만원 짜리 PC를
만들 수 있게 된다. 물론 그 이후 새로운 그래픽카드가 출시되면 PC에서 구형 그래픽카드만 때어내고 새로나온
신형 그래픽카드로 업그레이드 할 수 있다.

HDD, 메인보드.. 등과 같이 PC를 이루는 각 부품들이 바로 컴포넌트이며 이를 사용하여 조립할 수 있게 해주는
규격이 컴포넌트 오브젝트 모델이다.
*/

/*
Microsoft의 COM의 기능적인 특성
	1. COM 오브젝트는 인터페이스에 의해 실행되는 클래스 또는 클래스 집합이다.
	2. 인터페이스는 가상 함수의 집합이다.
	3. 인터페이스는 IDirect3DDevice처럼 I접두어가 붙는다.
	4. 각 오브젝트 및 인터페이스는 고유의 ID값을 가진다.
	5. C++ 객체와 같은 방식으로 생성하지 못한다.
		이를 쉽게 해주는 DirectX API의 헬퍼 함수들을 사용
		객체의 수명 역시 COM방식이 따로 존재
		사용후에는 꼭 Release()함수를 호출해야 함
			내부적으로 관리하기 때문에 new, delete를 사용하지 않음
	6. COM 오브젝트의 메서드들은 결과 코드를 나타내는 HRESULT를 반환
		32비트 정수로 성공/실패 여부 및 기타 정보를 나타냄
		Winerror.h에 대부분 정의되어 있음
		성공은 주로 S_ 로 시작하며 실패는 E_ 로 시작한다.
*/

/* Factory 패턴 */

/*
객체지향프로그래밍에서 클래스는 특정한 인스턴스를 생성하기 위한 정보들을 가지고 있는 것
인스턴스를 생성하기 위해서는 생성자를 이용해 특정 조건에 맞게 생성하기 위해 여러가지 정보들을
생성자의 매개변수로 넘겨준다. 매개변수도 중요하지만 동적 객체를 위해서는 메모리에 할당하는 방식도 중요,
OOP의 특징인 다형성으로 넘어가게 되면 어둑 더 복잡
*/

/*
int main()
	Character* pCharacter{};

	switch(job)
		case Warrior:
			pCharacter = new Warrior(...);
		...
	
위와 같이 각 직업에 맞게 생성자를 호출해줘야 하는데, 매우 불편, 업데이트로 신규 직업이 추가되면 더욱더 귀찬
이런 오브젝트의 생성을 관리하는 별도의 오브젝트가 있으면 좋음
결과 Factory 패턴, 오브젝트를 찍어내는 공장
*/

/* 포인터의 포인터 : 이중 포인터 */

/*
COM 객체 즉 DirectX를 사용하면 이런 형태를 자주 접하게됨
void Swap(int *a, int *b) {...}

int value1{1};
int value2{2};
Swap(&value1, &value2);

값으로 전달해서는 변수 값을 변경할 방법이 없음, 참조를 위해 포인터를 사용한 것
문자열을 매개변수로 사용하려면 다음과 같은 형태가 되어야 한다.
void Swap(char **a, char **b) {...}

char* value1{"ab"};
char* value2{"cd"};

Swap(&value1, &value2);
동적으로 생성된 자료구조는 특히 위와 같은 형태가 될 수 밖에 없으며, 이러한 것을 포인터의 포인터라고
부르는 개념이다. 참조형을 사용하지 않는 이유는 아직 다양한 플랫폼을 지원하기 위해서는 C++보다는 조금 더 빠른
C를 사용하기 떄문
*/

/* COM 객체의 함수 호출 */

/*
void **ppIDevice 
COM함수를 사용하다 보면 ** 포인터 포인터를 자주 보게된다.
위 매개변수를 풀어서 기술하자면 Deviec 인터페이스에 대한 포인터의 주소가 된다.
C++ 객체와 달리 COM객체는 함수에 바로 접근할 수 없다. 인터페이스에 대한 포인터를 획득한 다음
그 인터페이스에서 함수를 호출하는 방식을 취해야 한다.
IMyInterface* pIMy;
...
pIMy->Function();
그런데 인터페이스는 직접 생성하는 것이 아니라 대부분 COM에서 제공하는 헬퍼 함수를 통해 생성한다.
따라서 인터페이스를 생성하기 위해서는 주소를 넘겨줘야 한다.
IMyInterface* pIMy;
HRESULT hr = CreateMyCOM(&piMy);
pIMy->Function();
*/

/* 모니터와 픽셀 */

/*
초기에는 출력 값이 ON/OFF불빛으로 들어와서 하나 하나 해동해야 했지만, 모니터가 등장하면서 사용자
에게 시각적으로 결과를 보여 줄 수 있게 되었다. 화면에 어떤 멋진 최신 3D그래픽이 나오더라도 컴퓨터는
내부에서 0과 1들이 뭉치로만 인식할 뿐이라는 점
최초의 모니터는 화면에 0과 1만 표시할 수 있었기 떄문에 0(검은색) 1(흰색)의 흑백 모니터였다.
백열 전구들이 패널에 빼곡하게 나열되어 있었고 여기에 화면을 표시했다. 이런 전구 하나가
화면에 표시되는 화면의 원소가 된다고 하여 Pixel이라 불렸다.
또한 가로 x 세로 전구의 갯수를 Resolution 해상도라 한다.
기술이 조금 더 발전하면서 흑백이 아닌 칼라를 표시할 수 있게 되었는데 하나의 픽셀을 세분화한 Sub Pixel을
도입하면서 가능해졌다. 빛의 3요소인 RGB를 섞어서 표시한 것
화면의 점 하나(픽셀)은 RGB 세 개의 값을 조합해서 만들 수 있다.
*/

/* DPI */

/*
원래는 인쇄물에서 자주 사용되던 용어인데, 스마트 폰이 등장하고 작은 화면에서 높은 해상도를 보여주기
위해 사용된다.
1인치에 몇 개의 점이 들어가 있는가에 따른 단위로 높으면 높은 퀄리티의 이미지를 볼 수 있다.
PPI는 Pixel per Inch의 약자로 점이 아닌 픽셀이 기준, 모바일 개발을 진행하실 때 iOS는 DPI를 사용하고
Android는 PPI를 사용해서 조금 복잡하다.
*/

/* 감마 보정 */

/*
사람의 눈은 밝기에 대해 비선형적으로 반응한다. 아주 밝음이 1이고 아주 어두룸이 0이라고 가정하면 단계별로
차이를 느끼는 것이 아니라 어느 지점이 되면 어둡고 밝게 되는 것인데, 컴퓨터를 통해 얼마 되지 않는 색상으로
이미지를 표현하면 밝기를 변화시켜도 갑자기 안보이게 되는 단절현상이 발생하게 된다. 특히나 어두운 부분
에 대해서는 매우 심함
따라서 최소한의 색상 공간안에서 사람이 잘 구분할 수 있도록 색상 분포를 수정하는 작업을 감마보정이라 한다.
카메라로 촬영한 기본 색상은 1.0 직선처럼 생성되지만 ,실제로 사람의 눈이 인식하는 색상은 2.2곡선과 같은 형태로 분포됨

단순히 색상 공간을 32단계로 잘게 쪼개보면 선형 방식은 검은색 -> 흰색의 단계를 일정한 비율로 줄여
나가는 것이며, 감마 보간은 최대한 고르게 생상이 분포되도록 수정해 준 것
*/

/* 인라인 함수 */

/*
inline 키워드는 함수를 인라인 함수로 만들어 주는 것으로, 단어 그대로 줄 안에 있는 함수라는 뜻
즉, 함수를 개별 호출로 처리하는 것이 아니라 프로그램 코드 내부에 함수 코드를 삽입해 준다는 의미 #define 처럼

void f() {...}

int main()
	f();
일반적인 함수 호출 과정은 다음과 같다.
	1. main진입
	2. f()호출
	3. 호출 스택에 매개변수 정보들 저장
	4. f() 반환
	5. 호출 스택에서 POP
하지만 인라인 함수는 다음과 같다.
	1. main() 진입
	2. f() 해당하는 코드 실행
즉 함수 호출에 필요한 호출 스택에 정보를 PUSH, POP하는 과정이 없어서 빠르게 처리할 수 있다.
	장점 : 빠른 성능
	단점 : 자주 호출하는 인라인 함수는 코드의 양이 길어진다.

사용법
	일반 함수는 선언/정의 앞에 inline 키워드를 붙이면 된다.
inline void Test();

void Text();

inline void Test() {...}

	멤버 함수는 반드시 헤더파일에 정의해야 한다.
class MyClass
	inline void Func()
inline void MyClass::Func() {...}
*/

/* 그래픽 카드 */

/*
우리가 보는 모니터의 화면은 크게 보면 CPU, 그래픽카드, 모니터 출력의 과정으로 이뤄져 있다.
그래픽카드, 비디오카드, 디스플레이카드, 그래픽보드, 디스플레이어댑터, 비디오어댑터등 다양한 이름으로 불린다.
그래픽카드는 크게 다음과 같은 구성으로 되어 있다.
	GPU : 3차원 그래픽이 유행하면서 등장한 그래픽 연산 전용 CPU라고 생각하면 된다.
		CPU보다 빠른 소수점 연산 처리와 3D오브젝트를 화면의 픽셀로 변환하는 파이프라인으로 되어 있다.
	V-RAM : 그래픽에 사용되는 내용을 저장하는 전용 메모리, 이미지 파일로 로딩해서 저장한다든지 하거나
		3D 오브젝트의 점을 저장하는 용도로도 사용하지만 가장 큰 목적은 화면에 그릴 내용을 메모리에 들고 있는 것
		여기서 바로 모니터로 화면이 전송된다.
	출력 : 모니터와 연결하는 인터페이스, VGA단자, DVI, HDMI 등 다양한 규격이 존재
*/

/* 비트맵 */

/*
Bit + Map의 약자로 비트로 구성된 맵이라는 의미, 디지털 이미지를 저장하는 이미지 파일 포멧 중 하나이며
가장 기본적인 방식, 가로 / 세로로 구성된 배열에 픽셀을 표현하는 방식
픽셀 당 할다하는 비트의 크기에 따라 다양한 색을 표현할 수 있다.
과거에는 256색 이하의 색상을 조금 더 멋지게 그리기 위해 팔레트라는 개념을 사용해다.
색상 테이블을 별도로 준비해서 그 인덱스로 이미지를 표현하는 방식
24비트 이상에서는 그럴 필요가 없이 픽셀마다 직접 색상을 표현할 수 있게 되었다.
위와 같은 방식은 모니터으 ㅣ구성원리와 같은 방식이므로 컴퓨터가 알아먹기 쉽고 프로그래머도 이해하기
쉽지만, 이미지의 크기가 가로 너비 * 세로 높이 * 픽셀 당 비트 수이므로 상당히 크다,
따라서 요즘은 JPG, PNG 등 압축 포멧들을 많이 사용하고 있다.
*/

/* 싱글턴 패턴 */

/*
하나의 관리자, 여러 번 생성자가 불리더라고 인스턴스가 하나만 유지되는 형태, 싱글턴 패턴
	생성자가 여러 번 호출되어도 실제로 생성되는 객체는 하나
	또 다시 생성자가 호출되면, 최초 생성 이후에는 이미 생성된 객체를 반환
단 하나의 객체를 위해서는 어쩔 수 없이 정적 멤버를 사용할 수 밖에 없다마, 외부로 노출되지 않는 장점이 있다.
*/

/*
class Singleton final	매니저는 그 자체로 구현이 끝나는 클래스 : 더 이상 파생되어서는 안됨
public:
	static Singleton& Instance()	싱글턴 패턴은 지금까지의 객체 인스턴스화 방식과는 다르게 이 함수를 통해서 접근
		static Singleton instance;
		return instance;
private:	기본, 복사, 대입 생성자를 다른 곳에서 내부에 접근이 불가능 하도록 막음
	Singleton();
	Singleton(const Singleton&);
	void operator =(const Singleton&);
public:
	~Singleton();
public:
	void MyFunction();

Singleton::Instance().MyFunction();
*/

/*
싱글턴 패턴의 문제
	스레드 동시성 문제
	앱 종료시까지 메모리에 상주
	테스트가 어려움
		개별 단위로 테스트를 수행하는 것이 어려움
	순환 종속 발생
		A는 B의 싱글턴 사용
		B는 A의 인스턴스를 사용
		관리자를 만들다보면 위와 같은 경우가 많이 발생, 이러한 것을 순화 종속이라 부르며 OOP에서는 피하는 개념
	클래스 확장이 어려움
		OOP의 개방 폐쇄 개념
		싱글턴을 사용하면 구현과 인터페이스가 하나로 묶이게 되므로 확장성은 좋지 안다.
그러므로 모든 곳에서 접근이 필요한 관리자 객체에만 적용하는 것
*/

/* 이미지 보간 */

/*
실제로 우리가 보는 이미지는 모눈종이에 찍은 점, 그렇기 때문에 표현하려는 이미지가 정확하게 픽셀의 가운데가 될 수 없는 경우도 있다.
이러한 문제를 해결하기 위한 것이 보간이며 다음과 같은 방법이 자주 사용된다.
	Nearest-neighbor : 가장 가까운 픽셀을 선택
	Linear : 2개의 가까운 픽셀을 선택한 다음 선을 그리고 색상 중간 값으로 만듬
	Bulinear : 4개의 가까운 픽셀을 선택한 다음 각 픽셀의 평균 생각을 사용
	Trilinear : 8개의 가까운 픽생을 선택한 다음 평균 색상을 사용, 단 xyz좌표 평면을 사용하므로 주로 3D에서 사용
	Cubic : 16개의 픽셀을 선택하여 평균 색상을 사용
*/