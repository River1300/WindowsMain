/* COM : Component Object Model */

/*
재사용이 가능한 컴포넌트를 만들어 배포를 쉽게해준다.
용산에서 조립 PC를 하나 맞춘다고 생각해보자. 에산이 100만원이면 견적 사이트에서 원하는 HDD, 메인보드, CPU,
그래픽카드들을 찾아서 조합할것, 이런 각 부품들은 당연히 서로 하나로 조립이 가능하며, 100만원 짜리 PC를
만들 수 있게 된다. 물론 그 이후 새로운 그래픽카드가 출시되면 PC에서 구형 그래픽카드만 때어내고 새로나온
신형 그래픽카드로 업그레이드 할 수 있다.

HDD, 메인보드.. 등과 같이 PC를 이루는 각 부품들이 바로 컴포넌트이며 이를 사용하여 조립할 수 있게 해주는
규격이 컴포넌트 오브젝트 모델이다.
*/

/*
Microsoft의 COM의 기능적인 특성
	1. COM 오브젝트는 인터페이스에 의해 실행되는 클래스 또는 클래스 집합이다.
	2. 인터페이스는 가상 함수의 집합이다.
	3. 인터페이스는 IDirect3DDevice처럼 I접두어가 붙는다.
	4. 각 오브젝트 및 인터페이스는 고유의 ID값을 가진다.
	5. C++ 객체와 같은 방식으로 생성하지 못한다.
		이를 쉽게 해주는 DirectX API의 헬퍼 함수들을 사용
		객체의 수명 역시 COM방식이 따로 존재
		사용후에는 꼭 Release()함수를 호출해야 함
			내부적으로 관리하기 때문에 new, delete를 사용하지 않음
	6. COM 오브젝트의 메서드들은 결과 코드를 나타내는 HRESULT를 반환
		32비트 정수로 성공/실패 여부 및 기타 정보를 나타냄
		Winerror.h에 대부분 정의되어 있음
		성공은 주로 S_ 로 시작하며 실패는 E_ 로 시작한다.
*/

/* Factory 패턴 */

/*
객체지향프로그래밍에서 클래스는 특정한 인스턴스를 생성하기 위한 정보들을 가지고 있는 것
인스턴스를 생성하기 위해서는 생성자를 이용해 특정 조건에 맞게 생성하기 위해 여러가지 정보들을
생성자의 매개변수로 넘겨준다. 매개변수도 중요하지만 동적 객체를 위해서는 메모리에 할당하는 방식도 중요,
OOP의 특징인 다형성으로 넘어가게 되면 어둑 더 복잡
*/

/*
int main()
	Character* pCharacter{};

	switch(job)
		case Warrior:
			pCharacter = new Warrior(...);
		...
	
위와 같이 각 직업에 맞게 생성자를 호출해줘야 하는데, 매우 불편, 업데이트로 신규 직업이 추가되면 더욱더 귀찬
이런 오브젝트의 생성을 관리하는 별도의 오브젝트가 있으면 좋음
결과 Factory 패턴, 오브젝트를 찍어내는 공장
*/

/* 포인터의 포인터 : 이중 포인터 */

/*
COM 객체 즉 DirectX를 사용하면 이런 형태를 자주 접하게됨
void Swap(int *a, int *b) {...}

int value1{1};
int value2{2};
Swap(&value1, &value2);

값으로 전달해서는 변수 값을 변경할 방법이 없음, 참조를 위해 포인터를 사용한 것
문자열을 매개변수로 사용하려면 다음과 같은 형태가 되어야 한다.
void Swap(char **a, char **b) {...}

char* value1{"ab"};
char* value2{"cd"};

Swap(&value1, &value2);
동적으로 생성된 자료구조는 특히 위와 같은 형태가 될 수 밖에 없으며, 이러한 것을 포인터의 포인터라고
부르는 개념이다. 참조형을 사용하지 않는 이유는 아직 다양한 플랫폼을 지원하기 위해서는 C++보다는 조금 더 빠른
C를 사용하기 떄문
*/

/* COM 객체의 함수 호출 */

/*
void **ppIDevice 
COM함수를 사용하다 보면 ** 포인터 포인터를 자주 보게된다.
위 매개변수를 풀어서 기술하자면 Deviec 인터페이스에 대한 포인터의 주소가 된다.
C++ 객체와 달리 COM객체는 함수에 바로 접근할 수 없다. 인터페이스에 대한 포인터를 획득한 다음
그 인터페이스에서 함수를 호출하는 방식을 취해야 한다.
IMyInterface* pIMy;
...
pIMy->Function();
그런데 인터페이스는 직접 생성하는 것이 아니라 대부분 COM에서 제공하는 헬퍼 함수를 통해 생성한다.
따라서 인터페이스를 생성하기 위해서는 주소를 넘겨줘야 한다.
IMyInterface* pIMy;
HRESULT hr = CreateMyCOM(&piMy);
pIMy->Function();
*/

/* 모니터와 픽셀 */

/*
초기에는 출력 값이 ON/OFF불빛으로 들어와서 하나 하나 해동해야 했지만, 모니터가 등장하면서 사용자
에게 시각적으로 결과를 보여 줄 수 있게 되었다. 화면에 어떤 멋진 최신 3D그래픽이 나오더라도 컴퓨터는
내부에서 0과 1들이 뭉치로만 인식할 뿐이라는 점
최초의 모니터는 화면에 0과 1만 표시할 수 있었기 떄문에 0(검은색) 1(흰색)의 흑백 모니터였다.
백열 전구들이 패널에 빼곡하게 나열되어 있었고 여기에 화면을 표시했다. 이런 전구 하나가
화면에 표시되는 화면의 원소가 된다고 하여 Pixel이라 불렸다.
또한 가로 x 세로 전구의 갯수를 Resolution 해상도라 한다.
기술이 조금 더 발전하면서 흑백이 아닌 칼라를 표시할 수 있게 되었는데 하나의 픽셀을 세분화한 Sub Pixel을
도입하면서 가능해졌다. 빛의 3요소인 RGB를 섞어서 표시한 것
화면의 점 하나(픽셀)은 RGB 세 개의 값을 조합해서 만들 수 있다.
*/

/* DPI */

/*
원래는 인쇄물에서 자주 사용되던 용어인데, 스마트 폰이 등장하고 작은 화면에서 높은 해상도를 보여주기
위해 사용된다.
1인치에 몇 개의 점이 들어가 있는가에 따른 단위로 높으면 높은 퀄리티의 이미지를 볼 수 있다.
PPI는 Pixel per Inch의 약자로 점이 아닌 픽셀이 기준, 모바일 개발을 진행하실 때 iOS는 DPI를 사용하고
Android는 PPI를 사용해서 조금 복잡하다.
*/

/* 감마 보정 */

/*
사람의 눈은 밝기에 대해 비선형적으로 반응한다. 아주 밝음이 1이고 아주 어두룸이 0이라고 가정하면 단계별로
차이를 느끼는 것이 아니라 어느 지점이 되면 어둡고 밝게 되는 것인데, 컴퓨터를 통해 얼마 되지 않는 색상으로
이미지를 표현하면 밝기를 변화시켜도 갑자기 안보이게 되는 단절현상이 발생하게 된다. 특히나 어두운 부분
에 대해서는 매우 심함
따라서 최소한의 색상 공간안에서 사람이 잘 구분할 수 있도록 색상 분포를 수정하는 작업을 감마보정이라 한다.
카메라로 촬영한 기본 색상은 1.0 직선처럼 생성되지만 ,실제로 사람의 눈이 인식하는 색상은 2.2곡선과 같은 형태로 분포됨

단순히 색상 공간을 32단계로 잘게 쪼개보면 선형 방식은 검은색 -> 흰색의 단계를 일정한 비율로 줄여
나가는 것이며, 감마 보간은 최대한 고르게 생상이 분포되도록 수정해 준 것
*/