/* 좌표계( Coordinate System )및 기하학( Geometry ) */

/*
x 축 y축으로 되어 있던 평면은 르네 데카르트가 고안한 x-y평면 기하학에서 출발했다.
이러한 공간을 데카르트 좌표계라 부르며 X축 Y축이 교차하는 형태를 따서 직교 좌표계라 부른다.

도형은 표시하기 위한 최소 단위는 점이다. 이러한 점은 그 기준이 되는 축으로 수직으로 연결한 값을 좌표로 가지게 된다.
그래서 직교 좌표계라 부른다.

여기에 z축을 하나 추가하면 3차원 공간이 가능해 진다. x-y 평면, x-z 평면, y-z 평면 으로 이루어지는 이 좌표계는
z축의 방향에 따라 다음과 같이 두 가지로 나눠진다.

LEFT-HANDED Cartesian Coordinates
Y    Z
|   /
|  /
|ㅡㅡㅡㅡ X

RIGHT-HANDED Cartesian Coordinates
	Y
	|
	|
	|ㅡㅡㅡㅡ X
   -
  -
-
Z
손가락의 엄지 손가락 방향으로 z축이 증가한다라는 의미로 각각 왼손 좌표계, 오른손 좌표계라 부른다.
DirectX는 왼손 좌표계를 사용하며 OpenGL은 오른손 좌표계를 사용한다. 유니티나 언리언 엔진 역시 왼손좌표계를 사용한다.
( 축의 방향이 다른 경우도 있으며, 내부적으로는 더 다양한 좌표계가 사용된다. )
*/

/* Vertex & Vector */

/*
좌표계를 사용하면 공간에 꼭짓점( 정점, 단수 Vertex, 복수 Vertices )과 방향( Vector )을 지정할 수 있다. 여러 개의 버텍스를 사용
하면 선이나 도형을 만들 수 있게 된다. 이렇게 만들 수 있는 도형들 중 가장 기본 형태를 Primitives( 원형 )라 부르며 수 많은 Primitives
들로 이루어진 복잡한 도형을 메시( Mesh )라 부른다.

Mesh 라는 단어의 뜻이 그물망, 망사라는 뜻인데 3차원으로 표현한 도형의 형태가 Mesh 처럼 생겼기 때문이다.
폴리곤( Polygon, 다각형 )이라는 것이 있다. 이 폴리곤은 Primitives를 의미하는데, 초창기 가장 많이 사용된 오브젝트를 표현하는 가장 최소 단위
가 삼각형이었고 이를 폴리곤이라 불렀기 때문에 일반적으로 통용되고 있을 뿐이다. 최근에는 사각형을 Primitives로 사용하는 3D 편집
프로그램도 있기도 해서 기존의 삼각형 폴리곤과 구분하기 위해 Primitives라는 단어를 더 많이 사용하려고 하는 것 같다.

기본 요소들로 도형을 표현하는 방법을 저체적으로 살펴 보면 다음과 같다.

Vertices( 꼭짓점 ) : 도형을 구성하는 각 꼭짓점들의 정보( 도형의 기본 정보 )
Edges( 모서리 ) : 두 버텍스를 연결하면 모서리가 만들어 진다. 주어진 버텍스들로 만들 수 있는 모서리의 경우의 수는 매우 다양하므로
	모서리 정보가 매우 중요하다.
Faces( 면 ) : 엣지들을 연결하면 형태를 가지는 평면이 만들어 지는데, 3차원 공간이므로 그 평면이 어느쪽을 바라 보는지가 중요해 진다.
	이런 방향성을 지정하는 것이 Face
Polygons : Face가 지정되면 도형을 이루는 최소 단위인 폴리곤이 만들어 진다.
Surfaces : 동일한 특성을 가지는 폴리곤들을 묶어서 집합을 만들어 서피스라 부른다.

기본적으로 지금까지 경험한 3D 게임들은 모두 표면(Surface)를 표현한 것들 뿐이다. 3차원 오브젝트의 내적인 표현은 아직까지 개념이 없다.
*/

/* 법선 벡터( Normal Vector ) */

/*
메시의 각 페이스에 해당 페이스가 바라보는 방향을 나타내는 정보가 필요하다.
3차원 렌더링을 효율적으로 처리하기 위해 뒷면은 그리지 않는 방식을 사용하기 때문에 해당 정보는 매우 중요 하다.

이러한 정보를 법선 벡터라 부르며 해당 면에 수직인 단위 벡터( 길이가 1인 벡터 )를 사용한다. 이런 정보는 좌표계에 따라 정의 되며
왼손 좌표계에서는 버텍스의 시계 방향 순서로 결정된다.

그리고 버텍스에서 법선벡터가 존재하는데, 이 정보를 사용하여 음영처리를 할 수 있다.
*/

/* Transform */

/*
Direct2D 연슬할 때, 간약하게 이동, 회전, 크기에 대해 살펴 봤다. 3차원 공간의 버텍스를 모니터에 표현하기 위해선 매우 복잡한 변형이 이루어 진다.
각 변환들은 간단한 수학 공식으로 증명이 가능하다.

Model Space : 3D 오브젝트는 자체적인 원점을 가진 좌표계를 가지고 있다.
	보통 아티스트는 캐릭터를 원점 기준으로 모델링을 하고 리소스를 제공해 준다. 이러한 좌표가 로컬 좌표계라 하며 모델 공간이라고도
	한다. 이 단계에서는 변환 없이 디자인한 대로 버텍스들이 저장되어 있다.

World Transform : 게임에서는 다양한 오브젝트들을 배치해서 화면을 구성한다. 이 때 기준이 되는 좌표가 월드 좌표계이다.
	캐릭터를 월드에 배치하려면 위치를 지정하고 적당히 회전하고 크기도 조절해야 한다. 즉, 모델 공간에서 월드 공간으로 변환이 일어
	나는 것이다. 이 과정을 World Transform이라 부른다.

View Transform : 3D 환경은 표현을 위해 카메라를 사용하며, 그 카메라에 찍힌( 투영된 )이미지를 화면에 표시한다.
	이를 위해서 수행되는 변환을 View Transform 혹은 Camera Transform이라 한다. 이 역시 단순한 행렬의 곱셈일 뿐이다.
	카메라를 원점으로 하는 좌표계에 각 버텍스를 변환해서 배치한다고 생각하면 된다.

Projection Transform : 지금까지는 3차원 공간에서 점을 이리 저리 움직이는 과정일 뿐이었다. 하지만 모니터에 3차원 공간을 표현하기 위해서는
	투영이라는 과정이 필요하다. 흔히 미술 시간에 배운 원근법을 적용하거나 하는 기법을 사용한다.
	이러한 과정 역시 수학으로 표현이 가능하며, 이 과정을 Projection Transform이라 부른다.
	이 과정을 거치고 나면 3차원 공간의 버텍스들이 2차원 공간으로 투영된다.

Clipping ScreenSpace : 마지막으로 수행하는 과정이 모니터에 그리는 과정이다. 화면에 배치된 3D 모델에 색상을 입히고 셰이더를
	적용하고 특수효과를 입히는 마무리 단계이다.
	이 때 중요한 것은 화면에 보이지 않는 점들은 이런 복잡한 연산을 수행할 필요가 없다.
	3D 그래픽은 비주얼도 비주얼이지만 성능이 최우선이므로 불필요한 계산은 최대한 배제하는 것이 좋다.
	화면 공간으로 잘라 주는 작업을 Clipping이라 부른다.
	이렇게 잘라진 공간의 최종 버텍스들만 텍스쳐를 입히거나 음영 처리를 한다.
*/